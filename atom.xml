<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>好记忆不如烂笔头</title>
  
  <subtitle>问题记录，学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/fafucoder/"/>
  <updated>2023-02-04T14:05:26.223Z</updated>
  <id>https://github.com/fafucoder/</id>
  
  <author>
    <name>Dawn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新浪图床图片替换为腾讯COS</title>
    <link href="https://github.com/fafucoder/2023/02/04/golang-sina-image/"/>
    <id>https://github.com/fafucoder/2023/02/04/golang-sina-image/</id>
    <published>2023-02-04T13:39:04.000Z</published>
    <updated>2023-02-04T14:05:26.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>近期，有同学反馈，所有调用的微博图床图片都无法加载并提示“403 Forbidden”了。百度上说新浪开启了防盗链，查遍了网上一堆复制/粘贴出来的文章，不是开启反向代理就是更改请求头，但是这些方案都不行。最终方案只能自己自建图床（其实自建图床的成本并不高，只是自己懒得搞，注册了个七牛云的对象存储，但是需要绑定域名，所以上次只能作罢，这次就使用腾讯COS作为图床吧~），为了批量把文档中的新浪图片替换成腾讯cos，也是花了丢时间写了个脚本用于批量替换。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"io/fs"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"path"</span></span><br><span class="line"><span class="string">"path/filepath"</span></span><br><span class="line"><span class="string">"regexp"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/tencentyun/cos-go-sdk-v5"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">sinaImageCacheDir = <span class="string">"/tmp"</span></span><br><span class="line">mdFileDir         = <span class="string">"xxx"</span></span><br><span class="line">CosSecretId       = <span class="string">"xxx"</span></span><br><span class="line">CosSecretKey      = <span class="string">"xxx"</span></span><br><span class="line">CosBucketUrl      = <span class="string">"xxx"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mdFile <span class="keyword">struct</span> &#123;</span><br><span class="line">fileName       <span class="keyword">string</span></span><br><span class="line">filePath       <span class="keyword">string</span></span><br><span class="line">fileContent    <span class="keyword">string</span></span><br><span class="line">sinaImages     <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">downloadImages <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">cosImages      <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := createSinaImageCacheDir(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdFiles, err := listFileContent(mdFileDir)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> mdFiles &#123;</span><br><span class="line">downloadSinaImage(file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> mdFiles &#123;</span><br><span class="line">uploadTencentCos(file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> mdFiles &#123;</span><br><span class="line">replaceSinaImageUrl(file)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSinaImageCacheDir</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := os.Stat(sinaImageCacheDir)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> os.Mkdir(sinaImageCacheDir, fs.ModePerm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listFileContent</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="params">([]*mdFile, error)</span></span> &#123;</span><br><span class="line">fileName, err := filepath.Glob(fmt.Sprintf(<span class="string">"%s/*.md"</span>, dir))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdFiles := <span class="built_in">make</span>([]*mdFile, <span class="number">0</span>, <span class="built_in">len</span>(fileName))</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> fileName &#123;</span><br><span class="line"><span class="comment">// 获取文件列表</span></span><br><span class="line">_, file := path.Split(name)</span><br><span class="line">fileContent, err := os.ReadFile(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取新浪图片</span></span><br><span class="line">simaImages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">sinaImages := regexp.MustCompile(<span class="string">`https://tva1.sinaimg.cn/large/(\w+).jpg|.jpeg|.png`</span>).FindAllString(<span class="keyword">string</span>(fileContent), <span class="number">-1</span>)</span><br><span class="line">fmt.Printf(<span class="string">"sinaimages"</span>)</span><br><span class="line"><span class="keyword">for</span> _, imageUrl := <span class="keyword">range</span> sinaImages &#123;</span><br><span class="line">_, imageName := path.Split(imageUrl)</span><br><span class="line">simaImages[imageUrl] = imageName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdFiles = <span class="built_in">append</span>(mdFiles, &amp;mdFile&#123;</span><br><span class="line">fileName:    file,</span><br><span class="line">filePath:    name,</span><br><span class="line">fileContent: <span class="keyword">string</span>(fileContent),</span><br><span class="line">sinaImages:  simaImages,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mdFiles, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadSinaImage</span><span class="params">(file *mdFile)</span></span> &#123;</span><br><span class="line">downloadImagePaths := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> sinaImageUrl, sinaFileName := <span class="keyword">range</span> file.sinaImages &#123;</span><br><span class="line">resp, err := http.Get(sinaImageUrl)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">fmt.Printf(<span class="string">"failed get sina image, error=%v, statusCode=%v"</span>, err, resp.StatusCode)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileName := fmt.Sprintf(<span class="string">"%s/%s"</span>, sinaImageCacheDir, sinaFileName)</span><br><span class="line">out, err := os.Create(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"failed create file, err=%v, fileName=%v"</span>, err, fileName)</span><br><span class="line">_ = resp.Body.Close()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将响应流和文件流对接起来</span></span><br><span class="line">_, err = io.Copy(out, resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"failed io.Copy, err=%v"</span>, err)</span><br><span class="line">_ = resp.Body.Close()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">downloadImagePaths[sinaImageUrl] = fileName</span><br><span class="line">_ = resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file.downloadImages = downloadImagePaths</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传到腾讯cos</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uploadTencentCos</span><span class="params">(file *mdFile)</span></span> &#123;</span><br><span class="line">u, _ := url.Parse(CosBucketUrl)</span><br><span class="line">b := &amp;cos.BaseURL&#123;BucketURL: u&#125;</span><br><span class="line">c := cos.NewClient(b, &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;cos.AuthorizationTransport&#123;</span><br><span class="line">SecretID:  CosSecretId,</span><br><span class="line">SecretKey: CosSecretKey,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">cosImageUrls := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> sinaImageUrl, localFileName := <span class="keyword">range</span> file.downloadImages &#123;</span><br><span class="line">fd, err := os.Open(localFileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileName, ok := file.sinaImages[sinaImageUrl]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">_, err = c.Object.Put(context.Background(), fileName, fd, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"put image to cos failed, err=%v"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">cosImageUrls[sinaImageUrl] = fmt.Sprintf(<span class="string">"%s/%s"</span>, CosBucketUrl, fileName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file.cosImages = cosImageUrls</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSinaImageUrl</span><span class="params">(file *mdFile)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> sinaImageUrl, cosImageUrl := <span class="keyword">range</span> file.cosImages &#123;</span><br><span class="line">file.fileContent = strings.ReplaceAll(file.fileContent, sinaImageUrl, cosImageUrl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := os.WriteFile(file.filePath, []<span class="keyword">byte</span>(file.fileContent), <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"failed write file, err=%v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;近期，有同学反馈，所有调用的微博图床图片都无法加载并提示“403 Forbidden”了。百度上说新浪开启了防盗链，查遍了网上一堆复制/粘贴
      
    
    </summary>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/categories/golang/"/>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang中的goroutine死循环</title>
    <link href="https://github.com/fafucoder/2022/02/08/golang-dead-goroutine/"/>
    <id>https://github.com/fafucoder/2022/02/08/golang-dead-goroutine/</id>
    <published>2022-02-08T02:52:47.000Z</published>
    <updated>2022-02-08T02:59:01.444Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://juejin.cn/post/6969802234179616798" target="_blank" rel="noopener">https://juejin.cn/post/6969802234179616798</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考文档&quot;&gt;&lt;a href=&quot;#参考文档&quot; class=&quot;headerlink&quot; title=&quot;参考文档&quot;&gt;&lt;/a&gt;参考文档&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/6969802234179616798&quot; tar
      
    
    </summary>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/categories/golang/"/>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>DNS的相关知识</title>
    <link href="https://github.com/fafucoder/2022/01/06/linux-dns/"/>
    <id>https://github.com/fafucoder/2022/01/06/linux-dns/</id>
    <published>2022-01-06T15:03:56.000Z</published>
    <updated>2022-01-06T15:10:25.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么DNS解析系统"><a href="#什么DNS解析系统" class="headerlink" title="什么DNS解析系统"></a>什么DNS解析系统</h3><h3 id="相关名词概念"><a href="#相关名词概念" class="headerlink" title="相关名词概念"></a>相关名词概念</h3><h3 id="什么是EDNS"><a href="#什么是EDNS" class="headerlink" title="什么是EDNS"></a>什么是EDNS</h3><h3 id="搭建DNS服务器"><a href="#搭建DNS服务器" class="headerlink" title="搭建DNS服务器"></a>搭建DNS服务器</h3><h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么DNS解析系统&quot;&gt;&lt;a href=&quot;#什么DNS解析系统&quot; class=&quot;headerlink&quot; title=&quot;什么DNS解析系统&quot;&gt;&lt;/a&gt;什么DNS解析系统&lt;/h3&gt;&lt;h3 id=&quot;相关名词概念&quot;&gt;&lt;a href=&quot;#相关名词概念&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/categories/linux/"/>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>内容分发网络(CDN)的技术和原理</title>
    <link href="https://github.com/fafucoder/2021/12/26/linux-cdn/"/>
    <id>https://github.com/fafucoder/2021/12/26/linux-cdn/</id>
    <published>2021-12-26T08:07:12.000Z</published>
    <updated>2022-01-06T15:03:18.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>本文大部分内容都来源于 <a href="http://product.dangdang.com/605644064.html" target="_blank" rel="noopener">内容分发网络原理与实践</a> 这本书，这本书全面的阐述了CDN的方方面面，感兴趣的可以仔细阅读原文～</p></blockquote><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文大部分内容都来源于 &lt;a href=&quot;http://product.dangdang.com/60564406
      
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/categories/linux/"/>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes dns解析续</title>
    <link href="https://github.com/fafucoder/2021/12/26/kubernetes-dns1/"/>
    <id>https://github.com/fafucoder/2021/12/26/kubernetes-dns1/</id>
    <published>2021-12-26T03:27:15.000Z</published>
    <updated>2022-01-17T11:37:33.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在<a href="https://fafucoder.github.io/2020/07/08/kubernetes-dns/" target="_blank" rel="noopener">kubernetes dns解析</a>篇章中讲述了DNS的基本概念，这个篇章让我们深入的了解下DNS协议，以及kubernetes的DNS解析插件coreDNS的相关知识</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://www.cnblogs.com/lovezbs/p/13701185.html" target="_blank" rel="noopener">https://www.cnblogs.com/lovezbs/p/13701185.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;在&lt;a href=&quot;https://fafucoder.github.io/2020/07/08/kubernetes-dns/&quot; targ
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://github.com/fafucoder/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://github.com/fafucoder/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>linux lvs原理及实践</title>
    <link href="https://github.com/fafucoder/2021/12/19/linux-lvs/"/>
    <id>https://github.com/fafucoder/2021/12/19/linux-lvs/</id>
    <published>2021-12-19T09:01:20.000Z</published>
    <updated>2023-02-04T13:33:00.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>负载均衡(Load Balance)的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上，让每台服务器获取到适合自己处理能力的负载。在为高负载服务器分流的同时，还可以避免资源浪费。负载均衡的原理就是当用户的请求到达前端负载均衡器(Director Server)时，通过设置好的调度算法，智能均衡的将请求分发到后端真正服务器上(Real Server)。根据请求类型的不同可以将负载均衡分为四层负载均衡(L4)和七层负载均衡(L7)， 常见的负载均衡器包括LVS，Nginx, HAProxy等。</p><h3 id="LVS概述"><a href="#LVS概述" class="headerlink" title="LVS概述"></a>LVS概述</h3><p>LVS是Linux Virtual Server的简称， 也就是 Linux 虚拟服务器，工作在 OSI 模型的传输层，即四层负载均衡。LVS主要由两部分组成，包括ipvs和ipvsadm。</p><ul><li>ipvs(ip virtual server)：工作在内核空间，是真正生效实现调度的代码。</li><li>ipvsadm：工作在用户空间，叫 ipvsadm，负责为 ipvs 内核框架编写规则，定义谁是集群服务，而谁是后端真实的服务器(Real Server)</li></ul><h3 id="LVS-基本工作原理"><a href="#LVS-基本工作原理" class="headerlink" title="LVS 基本工作原理"></a>LVS 基本工作原理</h3><p>LVS的底层是利用NETIFILTER的钩子能力：</p><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gxv02bh3vzj30ow0c5dgv.jpg" alt="ipvs工作原理" title="">            </p><ol><li>当用户向负载均衡调度器（Director Server）发起请求，调度器将请求发往至内核空间</li><li>PREROUTING 链首先会接收到用户请求，判断目标 IP 确定是本机 IP，将数据包发往 INPUT 链</li><li>IPVS 是工作在 INPUT 链上的，当用户请求到达 INPUT 时，IPVS 会将用户请求和自己已定义好的集群服务进行比对，如果用户请求的就是定义的集群服务，那么此时 IPVS 会强行修改数据包里的目标 IP 地址及端口，并将新的数据包发往 POSTROUTING 链</li><li>POSTROUTING 链接收数据包后发现目标 IP 地址刚好是自己的后端服务器，那么此时通过选路，将数据包最终发送给后端的服务器</li></ol><h3 id="LVS-调度算法"><a href="#LVS-调度算法" class="headerlink" title="LVS 调度算法"></a>LVS 调度算法</h3><p>前言说到负载均衡器原理是根据负载均衡算法把请求转发到后端真实服务器上。LVS作为四层负载均衡器，针对不同的网络服务需求和服务器配置，LVS调度器实现了多种负载均衡调度算法，主要包括如下：</p><ol><li><p><strong>轮询调度 rr（Round Robin）</strong>：这种算法是最简单的，就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是简单。轮询算法假设所有的服务器处理请求的能力都是一样的，调度器会将所有的请求平均分配给每个真实服务器，不管后端 RS 配置和处理能力，非常均衡地分发下去。</p></li><li><p><strong>加权轮叫 wrr（Weighted Round Robin）</strong>：这种算法比 rr 的算法多了一个权重的概念，可以给 RS 设置权重，权重越高，那么分发的请求数越多，权重的取值范围 0 – 100。主要是对 rr 算法的一种优化和补充，LVS 会考虑每台服务器的性能，并给每台服务器添加要给权值，如果服务器 A 的权值为 1，服务器 B 的权值为 2，则调度到服务器 B 的请求会是服务器 A 的 2 倍。权值越高的服务器，处理的请求越多。</p></li><li><p><strong>最少链接 lc（Least Connections）</strong>：这个算法会根据后端 RS 的连接数来决定把请求分发给谁，比如 RS1 连接数比 RS2 连接数少，那么请求就优先发给 RS1。</p></li><li><p><strong>加权最少链接 wlc（Weighted Least Connections）</strong>：这个算法比最少链接 lc算法多了一个权重的概念。</p></li><li><p><strong>基于局部性的最少链接 lblc（Locality-Based Least Connections）</strong>：这个算法是针对目标 IP 地址的负载均衡，目前主要用于 Cache 集群系统。该算法根据请求的目标 IP 地址找出该目标 IP 地址最近使用的服务器，若该服务器 是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用 “最少链接” 的原则选出一个可用的服务 器，将请求发送到该服务器。</p></li><li><p><strong>复杂的基于局部性最少的连接算法 lblcr（Locality-Based Least Connections with Replication）*</strong>：这个算法也是针对目标 IP 地址的负载均衡，目前主要用于 Cache 集群系统。它与 LBLC 算法的不同之处是它要维护从一个 目标 IP 地址到一组服务器的映射，而 LBLC 算法维护从一个目标 IP 地址到一台服务器的映射。该算法根据请求的目标 IP 地址找出该目标 IP 地址对应的服务 器组，按 “最小连接” 原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器，若服务器超载；则按 “最小连接” 原则从这个集群中选出一 台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的 程度。</p></li><li><p><strong>目标地址散列 dh（Destination Hashing）</strong>：这个算法根据请求的目标 IP 地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p></li><li><p><strong>源地址散列 sh（Source Hashing）</strong>：这个调度算法根据请求的源 IP 地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p></li></ol><h3 id="LVS-工作模式"><a href="#LVS-工作模式" class="headerlink" title="LVS 工作模式"></a>LVS 工作模式</h3><p>根据负载均衡器对数据包的处理方式分类，LVS支持三种工作模式，分别为NAT模式，DR模式以及TUN模式。原生的LVS工作模式不支持FULLNAT，FULLNAT模式需要自己重新编译LVS。在介绍LVS工作模式之前有必要先解释下相关名词：</p><ul><li>DS：Director Server，指的是前端负载均衡器节点。</li><li>RS：Real Server，后端真实的工作服务器。</li><li>VIP：向外部直接面向用户请求，作为用户请求的目标的 IP 地址。</li><li>DIP：Director Server IP，主要用于和内部主机通讯的 IP 地址。</li><li>RIP：Real Server IP，后端服务器的 IP 地址。</li><li>CIP：Client IP，访问客户端的 IP 地址。</li></ul><h4 id="LVS-NAT模式"><a href="#LVS-NAT模式" class="headerlink" title="LVS NAT模式"></a>LVS NAT模式</h4><h5 id="LVS-NAT的工作原理"><a href="#LVS-NAT的工作原理" class="headerlink" title="LVS NAT的工作原理"></a>LVS NAT的工作原理</h5><ol><li>当用户请求到达 Director Server，此时请求的数据报文会先到内核空间的 PREROUTING 链。 此时报文的源 IP 为 CIP，目标 IP 为 VIP</li><li>PREROUTING 检查发现数据包的目标 IP 是本机，将数据包送至 INPUT 链</li><li>IPVS 比对数据包请求的服务是否为集群服务，若是，修改数据包的目标 IP 地址为后端服务器 IP，然后将数据包发至 POSTROUTING 链。 此时报文的源 IP 为 CIP，目标 IP 为 RIP</li><li>POSTROUTING 链通过选路，将数据包发送给 Real Server</li><li>Real Server 比对发现目标为自己的 IP，开始构建响应报文发回给 Director Server。 此时报文的源 IP 为 RIP，目标 IP 为 CIP</li><li>Director Server 在响应客户端前，此时会将源 IP 地址修改为自己的 VIP 地址，然后响应给客户端。 此时报文的源 IP 为 VIP，目标 IP 为 CIP</li></ol><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gxv0a244zyj30ou0dtmys.jpg" alt="LVS NAT模式" title="">            </p><h5 id="LVS-NAT模式特点"><a href="#LVS-NAT模式特点" class="headerlink" title="LVS NAT模式特点"></a>LVS NAT模式特点</h5><ul><li><strong>RS 应该使用私有地址，RS 的网关必须指向 DIP。</strong></li><li><strong>DIP 和 RIP 必须在同一个网段内。</strong></li><li>支持端口映射。</li><li>RS 可以使用任意操作系统。</li><li>请求和响应报文都需要经过 Director Server，高负载场景中，Director Server 易成为性能瓶颈。</li></ul><h5 id="LVS-NAT模式实践"><a href="#LVS-NAT模式实践" class="headerlink" title="LVS NAT模式实践"></a>LVS NAT模式实践</h5><p>一、使用Docker模拟(适用于没虚拟机的情况)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 起两个nginx容器，分别是 </span></span><br><span class="line">[root@localhost ~]# docker run -d -p 8000:8000 --name first -t jwilder/whoami</span><br><span class="line">[root@localhost ~]# docker run -d -p 8001:8000 --name second -t jwilder/whoami</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 获取容器的IP地址</span></span><br><span class="line">[root@localhost ~]# docker inspect -f '&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' first</span><br><span class="line">[root@localhost ~]# docker inspect -f '&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' second</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行curl获取结果(ip为步骤二返回的结果)</span></span><br><span class="line">[root@localhost ~]# curl 172.17.0.2:8000</span><br><span class="line">[root@localhost ~]# curl 172.17.0.3:8000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建ipvs规则</span></span><br><span class="line">[root@localhost ~]# ipvsadm -A -t 192.168.56.102:80 -s rr</span><br><span class="line">[root@localhost ~]# ipvsadm -a -t 192.168.56.102:80 -r 172.17.0.2:8000 -m</span><br><span class="line">[root@localhost ~]# ipvsadm -a -t 192.168.56.102:80 -r 172.17.0.3:8000 -m</span><br><span class="line">[root@localhost ~]# ipvsadm -Ln</span><br><span class="line">TCP  192.168.56.102:80 rr</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 172.17.0.2:8000              Masq    1      0          0         </span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 172.17.0.3:8000              Masq    1      0          0   </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证是否生效(返回结果一次是A，一次是B)</span></span><br><span class="line">[root@localhost ~]# curl 192.168.56.102</span><br><span class="line">I'm fdb291a03b87</span><br><span class="line">[root@localhost ~]# curl 192.168.56.102</span><br><span class="line">I'm 9799eb62225c</span><br></pre></td></tr></table></figure><p>二、使用虚拟机模拟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 前置条件：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   1. 虚拟机网段一致</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   2. 服务器2，3上部署了http服务器,且内容不一致</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在虚拟机1上执行， (本机IP为192.168.56.101)</span></span><br><span class="line">ipvsadm -A -t 192.168.57.4:80 -s rr</span><br><span class="line">ipvsadm -a -t 192.168.57.4:80 -r 192.168.56.102:80 -m</span><br><span class="line">ipvsadm -a -t 192.168.57.4:80 -r 192.168.56.104:80 -m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 开启ip forward</span></span></span><br><span class="line">echo 1 &gt;/proc/sys/net/ipv4/ip_forward</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在虚拟机2，3上执行，(本机IP为192.168.56.102， 192.168.56.104), 如果默认路由不设置为虚拟机1，发现是访问不通的</span></span><br><span class="line">ip route del default</span><br><span class="line">ip route add default via 192.168.56.101</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否能够访问, 在虚拟机1上执行curl</span></span><br><span class="line">curl 192.168.57.4</span><br></pre></td></tr></table></figure><h4 id="LVS-DR模式"><a href="#LVS-DR模式" class="headerlink" title="LVS DR模式"></a>LVS DR模式</h4><p>DR（Direct Routing 直接路由模式）模式时 LVS 调度器只接收客户发来的请求并将请求转发给后端服务器，后端服务器处理请求后直接把内容直接响应给客户，而不用再次经过 LVS 调度器。LVS 只需要将网络帧的 MAC 地址修改为某一台后端服务器 RS 的 MAC，该包就会被转发到相应的 RS 处理，注意此时的源 IP 和目标 IP 都没变。RS 收到 LVS 转发来的包时，链路层发现 MAC 是自己的，到上面的网络层，发现 IP 也是自己的，于是这个包被合法地接受，RS 感知不到前面有 LVS 的存在。而当 RS 返回响应时，只要直接向源 IP（即用户的 IP）返回即可，不再经过 LVS。</p><h5 id="LVS-DR模式工作原理"><a href="#LVS-DR模式工作原理" class="headerlink" title="LVS DR模式工作原理"></a>LVS DR模式工作原理</h5><ol><li>当用户请求到达 Director Server，此时请求的数据报文会先到内核空间的 PREROUTING 链。 此时报文的源 IP 为 CIP，目标 IP 为 VIP。</li><li>PREROUTING 检查发现数据包的目标 IP 是本机，将数据包送至 INPUT 链。</li><li>IPVS 比对数据包请求的服务是否为集群服务，若是，将请求报文中的源 MAC 地址修改为 DIP 的 MAC 地址，将目标 MAC 地址修改 RIP 的 MAC 地址，然后将数据包发至 POSTROUTING 链。 此时的源 IP 和目的 IP 均未修改，仅修改了源 MAC 地址为 DIP 的 MAC 地址，目标 MAC 地址为 RIP 的 MAC 地址。</li><li>由于 DS 和 RS 在同一个网络中，所以是通过二层来传输。POSTROUTING 链检查目标 MAC 地址为 RIP 的 MAC 地址，那么此时数据包将会发至 Real Server。</li><li>RS 发现请求报文的 MAC 地址是自己的 MAC 地址，就接收此报文。处理完成之后，将响应报文通过 lo 接口传送给 eth0 网卡然后向外发出。 此时的源 IP 地址为 VIP，目标 IP 为 CIP。</li><li>响应报文最终送达至客户端。</li></ol><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gxvmcgh1xwj30oy0dwq57.jpg" alt="LVS DR模式" title="">            </p><h5 id="LVS-DR模式特点"><a href="#LVS-DR模式特点" class="headerlink" title="LVS DR模式特点"></a>LVS DR模式特点</h5><ul><li>保证前端路由将目标地址为 VIP 报文统统发给 Director Server，而不是 RS。</li><li>RS 可以使用私有地址；也可以是公网地址，如果使用公网地址，此时可以通过互联网对 RIP 进行直接访问。</li><li>VIP与DIP，RIP可以不在同一网段中.</li><li>所有的请求报文经由 Director Server，但响应报文必须不能进过 Director Server。</li><li>不支持地址转换，也不支持端口映射。</li><li>RS 可以是大多数常见的操作系统。</li><li>RS 的网关绝不允许指向 DIP（因为我们不允许他经过 Director Server）。</li><li>RS 上的 lo 接口配置 VIP 的 IP 地址。</li><li><strong>RS 和 DS 必须在同一个物理网络中(同一机房中)。</strong></li></ul><h5 id="LVS-DR模式的相关问题"><a href="#LVS-DR模式的相关问题" class="headerlink" title="LVS DR模式的相关问题"></a>LVS DR模式的相关问题</h5><p>为了解决<code>保证前端路由将目标地址为 VIP 报文统统发给 Director Server，而不是 RS。</code>的问题一般有如下解决方案：</p><ul><li>在前端路由器做静态地址路由绑定，将对于 VIP 的地址仅路由到 Director Server。但用户未必有路由操作权限，因为有可能是运营商提供的，所以这个方法未必实用。</li><li>arptables：在 arp 的层次上实现在 ARP 解析时做防火墙规则，过滤 RS 响应 ARP 请求。这是由 iptables 提供的。</li><li>修改 RS 上内核参数（<code>arp_ignore</code> 和 <code>arp_announce</code>）将 RS 上的 VIP 配置在 lo 接口的别名上，并限制其不能响应对 VIP 地址解析请求。</li></ul><h5 id="关于arp-ignore和arp-announce"><a href="#关于arp-ignore和arp-announce" class="headerlink" title="关于arp_ignore和arp_announce"></a>关于arp_ignore和arp_announce</h5><p>arp_ignore：定义接收 ARP 请求时的响应级别 </p><ul><li>0：响应任意网卡上接收到的对本机 IP 地址的 ARP 请求（包括环回网卡），不论目的 IP 地址是否在接收网卡上</li><li>1：只响应目的 IP 地址为接收网卡地址的 ARP 请求 </li><li>2：只响应目的 IP 地址为接收网卡地址的 ARP 请求，且 ARP 请求的源 IP 地址必须和接收网卡的地址在同网段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arp_ignore - INTEGER</span><br><span class="line">    Define different modes for sending replies in response to</span><br><span class="line">    received ARP requests that resolve local target IP addresses:</span><br><span class="line">        0 - (default): reply for any local target IP address, configured on any interface</span><br><span class="line">        1 - reply only if the target IP address is local address configured on the incoming interface</span><br><span class="line">        2 - reply only if the target IP address is local address configured on the incoming interface</span><br><span class="line">            and both with the sender&#39;s IP address are part from same subnet on this interface</span><br><span class="line">        3 - do not reply for local addresses configured with scope host,</span><br><span class="line">            only resolutions for global and link addresses are replied</span><br><span class="line">        4-7 - reserved</span><br><span class="line">        8 - do not reply for all local addresses</span><br><span class="line"></span><br><span class="line">    The max value from conf&#x2F;&#123;all,interface&#125;&#x2F;arp_ignore is used</span><br><span class="line">    when ARP request is received on the &#123;interface&#125;</span><br></pre></td></tr></table></figure><p>arp_announce：定义将自己地址向外通告时的通告级别 </p><ul><li>0：允许任意网卡上的任意地址向外通告 </li><li>1：尽量仅向目标网络通告与其网络匹配的地址 </li><li>2：仅向与本地接口上地址匹配的网络进行通告</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">arp_announce - INTEGER</span><br><span class="line">    Define different restriction levels for announcing the local source IP address</span><br><span class="line">    from IP packets in ARP requests sent on interface:</span><br><span class="line">        0 - (default) Use any local address, configured on any interface</span><br><span class="line">        1 - Try to avoid local addresses that are not in the target&#39;s subnet for this interface.</span><br><span class="line">            This mode is useful when target hosts reachable via this interface require the source IP</span><br><span class="line">            address in ARP requests to be part of their logical network configured on the receiving</span><br><span class="line">            interface. When we generate the request we will check all our subnets that include the</span><br><span class="line">            target IP and will preserve the source address if it is from such subnet.</span><br><span class="line">            If there is no such subnet we select source address according to the rules for level 2.</span><br><span class="line">        2 - Always use the best local address for this target. In this mode we ignore the source</span><br><span class="line">            address in the IP packet and try to select local address that we prefer for talks</span><br><span class="line">            with the target host. Such local address is selected by looking for primary IP addresses</span><br><span class="line">            on all our subnets on the outgoing interface that include the target IP address.</span><br><span class="line">            If no suitable local address is found we select the first local address we have on the</span><br><span class="line">            outgoing interface or on all other interfaces, with the hope we will receive reply</span><br><span class="line">            for our request and even sometimes no matter the source IP address we announce.</span><br><span class="line"></span><br><span class="line">    The max value from conf&#x2F;&#123;all,interface&#125;&#x2F;arp_announce is used.</span><br><span class="line"></span><br><span class="line">    Increasing the restriction level gives more chance for receiving answer from the resolved target</span><br><span class="line">    while decreasing the level announces more valid sender&#39;s information.</span><br></pre></td></tr></table></figure><h5 id="LVS-DR模式实践"><a href="#LVS-DR模式实践" class="headerlink" title="LVS DR模式实践"></a>LVS DR模式实践</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 前置条件：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   1. 虚拟机网段一致</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   2. 服务器2，3上部署了http服务器,且内容不一致</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在虚拟机1上执行， (本机IP为192.168.56.101)</span></span><br><span class="line">ip addr add 192.168.56.200/32 dev enp0s8</span><br><span class="line">ipvsadm -A -t 192.168.56.200:80 -s wrr</span><br><span class="line">ipvsadm -a -t 192.168.56.200:80 -r 192.168.56.102:80 -g -w 1</span><br><span class="line">ipvsadm -a -t 192.168.56.200:80 -r 192.168.56.104:80 -g -w 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 开启ip forward</span></span></span><br><span class="line">echo 1 &gt;/proc/sys/net/ipv4/ip_forward</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在虚拟机2，3上执行，(本机IP为192.168.56.102， 192.168.56.104)</span></span><br><span class="line">ip addr add 192.168.56.200/32 dev lo</span><br><span class="line">ip route add 192.168.56.200 dev lo</span><br><span class="line">echo "1" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">echo "2" &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">echo "1" &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">echo "2" &gt;/proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否能够访问, 在外部主机上执行curl</span></span><br><span class="line">curl 192.168.56.200</span><br></pre></td></tr></table></figure><h4 id="LVS-TUN-模式"><a href="#LVS-TUN-模式" class="headerlink" title="LVS TUN 模式"></a>LVS TUN 模式</h4><blockquote><p>TUN工作在三层，TAP工作在二层</p></blockquote><h5 id="LVS-TUN模式工作原理"><a href="#LVS-TUN模式工作原理" class="headerlink" title="LVS TUN模式工作原理"></a>LVS TUN模式工作原理</h5><ol><li>当用户请求到达 Director Server，此时请求的数据报文会先到内核空间的 PREROUTING 链。 此时报文的源 IP 为 CIP，目标 IP 为 VIP。</li><li>PREROUTING 检查发现数据包的目标 IP 是本机，将数据包送至 INPUT 链。</li><li>IPVS 比对数据包请求的服务是否为集群服务，若是，在请求报文的首部再次封装一层 IP 报文，封装源 IP 为 DIP，目标 IP 为 RIP。然后发至 POSTROUTING 链。 此时源 IP 为 DIP，目标 IP 为 RIP。</li><li>POSTROUTING 链根据最新封装的 IP 报文，将数据包发至 RS（因为在外层封装多了一层 IP 首部，所以可以理解为此时通过隧道传输）。 此时源 IP 为 DIP，目标 IP 为 RIP。</li><li>RS 接收到报文后发现是自己的 IP 地址，就将报文接收下来，拆除掉最外层的 IP 后，会发现里面还有一层 IP 首部，而且目标是自己的 lo 接口 VIP，那么此时 RS 开始处理此请求，处理完成之后，通过 lo 接口送给 eth0 网卡，然后向外传递。 此时的源 IP 地址为 VIP，目标 IP 为 CIP。</li><li>响应报文最终送达至客户端。</li></ol><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gxvobeirpcj30p00e340q.jpg" alt="LVS TUN模式" title="">            </p><h5 id="LVS-TUN模式特点"><a href="#LVS-TUN模式特点" class="headerlink" title="LVS TUN模式特点"></a>LVS TUN模式特点</h5><ul><li>不改变请求数据包，而是在请求数据包上新增一层 IP 首部信息。因此负载均衡器不能对端口进行转发，但可以和真实服务器不在同一局域网内，且真实服务器需要支持能够解析两层 IP 首部信息，即需要支持“IP Tunneling”或“IP Encapsulation”协议</li><li>真实服务器中的 VIP，只能被自己 “看见”，其他设备不可知。因此 VIP 必须绑定在真实服务器的 lo 网卡上，并且不允许将此网卡信息经过 ARP 协议对外通告</li><li>请求的数据包经过负载均衡器后，直接由真实服务器返回给客户端，响应数据包不需要再经过负载均衡器</li><li>RS 的网关不会也不可能指向 DIP。</li></ul><h5 id="LVS-TUN模式实践"><a href="#LVS-TUN模式实践" class="headerlink" title="LVS TUN模式实践"></a>LVS TUN模式实践</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 前置条件：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   2. 服务器2，3上部署了http服务器,且内容不一致</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在虚拟机1上执行， (本机IP为192.168.56.101)</span></span><br><span class="line">ip addr add 192.168.56.210/32 dev enp0s8</span><br><span class="line">ipvsadm -A -t 192.168.56.210:80 -s rr</span><br><span class="line">ipvsadm -a -t 192.168.56.210:80 -r 192.168.56.102:80 -i</span><br><span class="line">ipvsadm -a -t 192.168.56.210:80 -r 192.168.56.104:80 -i</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在虚拟机2，3上执行，(本机IP为192.168.56.102， 192.168.56.104)</span></span><br><span class="line">modprobe ipip // 启用ipip</span><br><span class="line">lsmod | grep ipip</span><br><span class="line">ip addr add 192.168.56.210/32 dev tunl0</span><br><span class="line">ip link set tunl0 up</span><br><span class="line">ip route add 192.168.56.210 dev tunl0</span><br><span class="line"></span><br><span class="line">echo 1 &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">echo 2 &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">echo 1 &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">echo 2 &gt;/proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">echo 0 &gt; /proc/sys/net/ipv4/conf/tunl0/rp_filter</span><br><span class="line">echo 0 &gt; /proc/sys/net/ipv4/conf/all/rp_filter</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否能够访问, 在外部主机上执行curl</span></span><br><span class="line">curl 192.168.56.210</span><br></pre></td></tr></table></figure><h4 id="LVS-FULLNAT模式"><a href="#LVS-FULLNAT模式" class="headerlink" title="LVS FULLNAT模式"></a>LVS FULLNAT模式</h4><p>LVS NAT, DR模式中，RS跟DS必须在同一个VLAN中，当集群规模较小时，使用 NAT、DR 模式都是没有问题的，当集群内有几十台以上时，那么这些服务器通常都不在同一个 VLAN/网段 内了。这时，必须再研发出一种能支持跨 VLAN/网段 通信的模式，FULLNAT 模式就是为了解决这个问题而生的。</p><p>LVS FullNAT 模式几乎和 LVS NAT 模式相同，不同之处即是：引入 Local Address（内网 IP 地址）。CIP-&gt;VIP 转换换为 LIP-&gt;RIP，而 LIP 和 RIP 均为 IDC 内网 IP，因此可以跨 VLAN 通讯。LVS原生模式不支持FULLNAT，因此需要自己手动编译内核～</p><h5 id="LVS-FULLNAT内核编译"><a href="#LVS-FULLNAT内核编译" class="headerlink" title="LVS FULLNAT内核编译"></a>LVS FULLNAT内核编译</h5><blockquote><p>注意：内核编译的内核包需要跟自己的操作系统内核版本对应上(大版本对应上~)，暂时未找到centos7对应的内核包在哪儿。</p><p>本机的内核版本为：2.6.32-220</p></blockquote><ol><li>安装依赖</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum -y install elfutils-devel.x86_64 audit-libs-devel.x86_64</span><br><span class="line">yum -y install rpmdevtools yum-utils</span><br><span class="line">yum -y install redhat-rpm-config</span><br><span class="line">yum -y install gcc xmlto patchutils asciidoc zlib-devel binutils-devel newt-devel python-devel hmaccalc perl-ExtUtils-Embed.x86_64</span><br><span class="line">yum -y install rng-tools 随机数生成器</span><br><span class="line">yum -y install bison</span><br></pre></td></tr></table></figure><ol start="2"><li>下载内核包，ipvs补丁包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 内核包</span></span><br><span class="line">wget ftp://ftp.redhat.com/pub/redhat/linux/enterprise/6Server/en/os/SRPMS/kernel-2.6.32-220.23.1.el6.src.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> lvs fullnat包</span></span><br><span class="line">wget http://kb.linuxvirtualserver.org/images/a/a5/Lvs-fullnat-synproxy.tar.gz</span><br></pre></td></tr></table></figure><ol start="3"><li>生成内核代码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh kernel-2.6.32-220.23.1.el6.src.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成随机数(一定要生成随机数，否则rpmbuild的时候会卡住)</span></span><br><span class="line">rngd -r /dev/urandom   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rpmbuild -bp kernel.spec</span></span><br><span class="line">cd ~/rpmbuild/SPECS</span><br><span class="line"></span><br><span class="line">rpmbuild -bp --target=$(uname -m) kernel.spec</span><br></pre></td></tr></table></figure><pre><code>4. 打 LVS补丁</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Lvs-fullnat-synproxy.tar.gz</span><br><span class="line"></span><br><span class="line">cp ~/lvs-fullnat-synproxy/lvs-2.6.32-220.23.1.el6.patch ~/rpmbuild/BUILD/kernel-2.6.32-220.23.1.el6/linux-2.6.32-220.23.1.el6.x86_64 &amp;&amp; cd $_</span><br><span class="line"></span><br><span class="line">patch -p1 &lt; lvs-2.6.32-220.23.1.el6.patch</span><br></pre></td></tr></table></figure><ol start="5"><li>编译内核</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 最好不要重新修改内核版本(遇到过改了内核版本后，编译没问题，重启后触发Kernel panic – not syncing: Attempted to <span class="built_in">kill</span> init的问题)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用-j 加快内核编译速度</span></span><br><span class="line">make -j16</span><br><span class="line">make modules_install</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ol start="6"><li>重启操作系统</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启后发现系统版本已经改变了， Linux localhost.localdomain 2.6.32 <span class="comment">#2 SMP Thu Dec 30 03:38:53 EST 2021 x86_64 x86_64 x86_64 GNU/Linux</span></span></span><br></pre></td></tr></table></figure><ol start="7"><li>编译ipvsadm, keepalived等工具</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd ~/lvs-fullnat-synproxy &amp;&amp; tar -zxvf lvs-tools.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 keepalived</span></span><br><span class="line">cd ~/lvs-fullnat-synproxy/tools/keepalived</span><br><span class="line">./configure --with-kernel-dir="/lib/modules/`uname -r`/build" &amp;&amp; make &amp;&amp; make install</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 ipvsadm</span></span><br><span class="line">cd ~/lvs-fullnat-synproxy/tools/ipvsadm</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 quaage</span></span><br><span class="line">cd ~/lvs-fullnat-synproxy/tools/quagga</span><br><span class="line">./configure --disable-ripd --disable-ripngd --disable-bgpd --disable-watchquagga --disable-doc  --enable-user=root --enable-vty-group=root --enable-group=root --enable-zebra --localstatedir=/var/run/quagga &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><ol start="8"><li>验证是否编译成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输入 ipvsadm -h 可以看到有fullnat 模式</span></span><br><span class="line"></span><br><span class="line">  --gatewaying   -g                   gatewaying (direct routing) (default)</span><br><span class="line">  --ipip         -i                   ipip encapsulation (tunneling)</span><br><span class="line">  --fullnat      -b                   fullnat mode</span><br><span class="line">  --masquerading -m                   masquerading (NAT)</span><br></pre></td></tr></table></figure><h5 id="LVS-FULLNAT模式工作原理"><a href="#LVS-FULLNAT模式工作原理" class="headerlink" title="LVS FULLNAT模式工作原理"></a>LVS FULLNAT模式工作原理</h5><ol><li>当用户请求到达 Director Server，此时请求的数据报文会先到内核空间的 PREROUTING 链。 此时报文的源 IP 为 CIP，目标 IP 为 VIP</li><li>PREROUTING 检查发现数据包的目标 IP 是本机，将数据包送至 INPUT 链</li><li>IPVS 比对数据包请求的服务是否为集群服务，若是，修改数据包的源IP地址分发服务器IP，目标 IP 地址为后端服务器 IP，然后将数据包发至 POSTROUTING 链。 此时报文的源 IP 为 DIP，目标 IP 为 RIP</li><li>POSTROUTING 链通过选路，将数据包发送给 Real Server</li><li>Real Server 比对发现目标为自己的 IP，开始构建响应报文发回给 Director Server。 此时报文的源 IP 为 RIP，目标 IP 为 DIP</li><li>Director Server 在响应客户端前，此时会将源 IP 地址修改为自己的 VIP 地址，然后响应给客户端。 此时报文的源 IP 为 VIP，目标 IP 为 CIP</li></ol><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gxw0gf5xdlj30lr0ck0tc.jpg" alt="LVS FULLNAT模式" title="">            </p><h5 id="LVS-FULLNAT模式实践"><a href="#LVS-FULLNAT模式实践" class="headerlink" title="LVS FULLNAT模式实践"></a>LVS FULLNAT模式实践</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 虚拟机4的IP地址为192.168.58.100， 虚拟机2，3的IP地址为192.168.56.102， 192.168.56.104, 在虚拟机上执行：</span></span><br><span class="line">ip addr add 192.168.58.200/32 dev eth1</span><br><span class="line"></span><br><span class="line">ipvsadm -A -t 192.168.58.200:80 -s wrr</span><br><span class="line">ipvsadm -a -t 192.168.58.200:80 -r 192.168.56.102:80 -b -w 2</span><br><span class="line">ipvsadm -a -t 192.168.58.200:80 -r 192.168.56.104:80 -b -w 1</span><br><span class="line">ipvsadm -P -t 192.168.58.200:80 -z 192.168.58.100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群外执行curl, 验证是否成功</span></span><br><span class="line">curl 192.168.56.200</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://github.com/xgfone/snippet/blob/master/snippet/docs/architecture/ha-lb/lvs-lb-and-install.md">LVS 负载均衡原理及安装配置详解</a>  // 推荐阅读</li><li><a href="https://wsgzao.github.io/post/lvs/" target="_blank" rel="noopener">LVS 原理介绍和配置实践</a>  // 推荐阅读</li><li><a href="https://segmentfault.com/a/1190000039819984" target="_blank" rel="noopener">深入浅出 LVS 负载均衡系列（一）：NAT、FULLNAT 模型原理</a>  //这系列文章不错</li><li><a href="https://segmentfault.com/a/1190000039932089" target="_blank" rel="noopener">深入浅出 LVS 负载均衡系列（二）：DR、TUN 模型原理</a>  //这系列文章不错</li><li><a href="https://segmentfault.com/a/1190000040190992" target="_blank" rel="noopener">深入浅出 LVS 负载均衡（三）实操 NAT、DR 模型</a>    //这系列文章不错</li><li><a href="https://www.haxi.cc/archives/LVS-FULLNAT实战.html" target="_blank" rel="noopener">LVS FULLNAT 实战</a>   // lvs fullnat 编译，样例</li><li><a href="http://kb.linuxvirtualserver.org/wiki/IPVS_FULLNAT_and_SYNPROXY" target="_blank" rel="noopener">IPVS FULLNAT and SYNPROXY</a>  // 编译 lvs fullnat</li><li><a href="https://blog.csdn.net/chao199512/article/details/81390485" target="_blank" rel="noopener">LVS/fullnat模式（内核编译）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;负载均衡(Load Balance)的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上，让每台服务器获取到适合自己处理能力的负载。
      
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/categories/linux/"/>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/fafucoder/2021/12/17/hello-world/"/>
    <id>https://github.com/fafucoder/2021/12/17/hello-world/</id>
    <published>2021-12-17T07:42:48.328Z</published>
    <updated>2021-12-17T07:42:48.328Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>golang中锁的实现原理</title>
    <link href="https://github.com/fafucoder/2021/11/22/golang-metux/"/>
    <id>https://github.com/fafucoder/2021/11/22/golang-metux/</id>
    <published>2021-11-22T13:35:17.000Z</published>
    <updated>2021-12-17T07:42:48.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://nxw.name/2021/golang-mutexde-shi-xian-yuan-li-1ef30cc7" target="_blank" rel="noopener">https://nxw.name/2021/golang-mutexde-shi-xian-yuan-li-1ef30cc7</a>  // 这边文章值得好好看</li><li><a href="https://cloud.tencent.com/developer/article/1493418" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1493418</a>   // 死锁的产生条件</li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#cond" target="_blank" rel="noopener">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#cond</a>  // 面向信仰编程，这文章也挺不错的~</li><li><a href="https://segmentfault.com/a/1190000039712353" target="_blank" rel="noopener">https://segmentfault.com/a/1190000039712353</a>  // 这文章也不错</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考文档&quot;&gt;&lt;a href=&quot;#参考文档&quot; class=&quot;headerlink&quot; title=&quot;参考文档&quot;&gt;&lt;/a&gt;参考文档&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nxw.name/2021/golang-mutexde-shi-xian-y
      
    
    </summary>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/categories/golang/"/>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>什么是云原生</title>
    <link href="https://github.com/fafucoder/2021/11/22/kubernetes-cloud-native/"/>
    <id>https://github.com/fafucoder/2021/11/22/kubernetes-cloud-native/</id>
    <published>2021-11-22T09:23:10.000Z</published>
    <updated>2021-12-17T07:42:48.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是云原生"><a href="#什么是云原生" class="headerlink" title="什么是云原生"></a>什么是云原生</h3><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://juejin.cn/post/6844904197859590151" target="_blank" rel="noopener">https://juejin.cn/post/6844904197859590151</a></li><li><a href="https://jimmysong.io/kubernetes-handbook/cloud-native/cloud-native-definition.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/cloud-native/cloud-native-definition.html</a></li><li><a href="https://tech.meituan.com/2020/03/12/cloud-native-security.html" target="_blank" rel="noopener">https://tech.meituan.com/2020/03/12/cloud-native-security.html</a>   //美团容器安全实践，说的不错</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是云原生&quot;&gt;&lt;a href=&quot;#什么是云原生&quot; class=&quot;headerlink&quot; title=&quot;什么是云原生&quot;&gt;&lt;/a&gt;什么是云原生&lt;/h3&gt;&lt;h3 id=&quot;参考文档&quot;&gt;&lt;a href=&quot;#参考文档&quot; class=&quot;headerlink&quot; title=&quot;参
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://github.com/fafucoder/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://github.com/fafucoder/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>golang 垃圾回收算法</title>
    <link href="https://github.com/fafucoder/2021/11/14/golang-gc/"/>
    <id>https://github.com/fafucoder/2021/11/14/golang-gc/</id>
    <published>2021-11-14T02:09:38.000Z</published>
    <updated>2021-12-17T07:42:48.326Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://www.cnblogs.com/33debug/p/12106823.html" target="_blank" rel="noopener">golang垃圾回收gc</a>   // 推荐阅读此大佬的所有go文章，写得针不戳</li><li><a href="https://blog.csdn.net/u010649766/article/details/80582153" target="_blank" rel="noopener">Golang GC 垃圾回收机制详解</a>   // 对常见的gc做了说明</li><li><a href="https://zhuanlan.zhihu.com/p/95056679" target="_blank" rel="noopener">万字长文深入浅出 Golang Runtime</a>   //之前go夜读有看到分享，说的贼好</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考文档&quot;&gt;&lt;a href=&quot;#参考文档&quot; class=&quot;headerlink&quot; title=&quot;参考文档&quot;&gt;&lt;/a&gt;参考文档&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/33debug/p/12106823.html
      
    
    </summary>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/categories/golang/"/>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang中的内存分配</title>
    <link href="https://github.com/fafucoder/2021/11/11/golang-memory/"/>
    <id>https://github.com/fafucoder/2021/11/11/golang-memory/</id>
    <published>2021-11-11T09:21:46.000Z</published>
    <updated>2021-12-17T07:42:48.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Go语言内置运行时(Runtime), 抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p><p>Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的<code>TCMalloc算法</code>，全称<code>Thread-Caching Malloc</code>。核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。</p><h3 id="TC-Malloc原理"><a href="#TC-Malloc原理" class="headerlink" title="TC Malloc原理"></a>TC Malloc原理</h3><h3 id="go-内存分配"><a href="#go-内存分配" class="headerlink" title="go 内存分配"></a>go 内存分配</h3><h3 id="make与new的区别"><a href="#make与new的区别" class="headerlink" title="make与new的区别"></a>make与new的区别</h3><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/95056679" target="_blank" rel="noopener">万字长文深入浅出 Golang Runtime</a>   // go夜读的分享，推荐去看下go夜读</p></li><li><p><a href="https://www.cnblogs.com/jiujuan/p/13869547.html" target="_blank" rel="noopener">TC Malloc 内存分配原理简析</a>   // 简洁tc malloc的原理</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/59125443" target="_blank" rel="noopener">图解Go语言内存分配</a>   // 绕全成大佬写的，通俗易懂</p></li><li><p><a href="https://www.cnblogs.com/33debug/p/12068699.html" target="_blank" rel="noopener">golang内存分配原理及make和new的区别</a>   // 强烈推荐这篇文档，这位大佬的go系列文章都很牛批</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Go语言内置运行时(Runtime), 抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等
      
    
    </summary>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/categories/golang/"/>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>goroutine并发数量控制</title>
    <link href="https://github.com/fafucoder/2021/11/09/golang-goroutine-count/"/>
    <id>https://github.com/fafucoder/2021/11/09/golang-goroutine-count/</id>
    <published>2021-11-09T02:02:02.000Z</published>
    <updated>2023-02-04T13:33:00.724Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在golang语言中创建协程（Goroutine）的成本非常低，因此稍不注意就可能创建出大量的协程，一方面会造成资源的浪费，例如有一万个任务需要处理，如果启用一万个goroutine同时处理，意味了CPU内存资源大量的飙升，所以一般会控制goroutine的数量，例如最多只有一百个goroutine在运行，本章将看下如何控制goroutine的并发数量</p><h3 id="goroutine并发控制"><a href="#goroutine并发控制" class="headerlink" title="goroutine并发控制"></a>goroutine并发控制</h3><h5 id="并发未控制情形"><a href="#并发未控制情形" class="headerlink" title="并发未控制情形"></a>并发未控制情形</h5><p>在说明goroutine并发控制前，先看下并发不控制的代码逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">workerCount := <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">"i am goroutine %d \n"</span>, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"worker have done"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的输出如下, 在多核的场景下，goroutine不一定是顺序输出的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">i am goroutine 88 </span><br><span class="line">i am goroutine 63 </span><br><span class="line">i am goroutine 89 </span><br><span class="line">i am goroutine 98 </span><br><span class="line">i am goroutine 82 </span><br><span class="line">i am goroutine 93 </span><br><span class="line">i am goroutine 87 </span><br><span class="line">i am goroutine 95 </span><br><span class="line">i am goroutine 97 </span><br><span class="line">worker have done</span><br></pre></td></tr></table></figure><p>下图展示了为每个 job 创建一个 goroutine 的情况（换句话说，goroutine 的数量是不受控制的）。此种情况虽然生成了很多的 goroutine，但是每个 CPU 核上同一时间只能执行一个 goroutine；当 job 很多且生成了相应数目的 goroutine 后，会出现很多等待执行的 goroutine，从而造成资源上的浪费。</p><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gwa9ewaz1uj31360hijso.jpg" alt="goroutine并发不控制" title="">            </p><h5 id="并发控制概述"><a href="#并发控制概述" class="headerlink" title="并发控制概述"></a>并发控制概述</h5><p>给每个 job 生成一个 goroutine 的方式显得粗暴了很多，那么可以通过什么样的方式控制 goroutine 的数目呢？其实上面的代码通过一个 for-range 循环完成了两件事情：①为每个 job 创建 goroutine；②把任务相关的标识传给相应的 goroutine 执行。为了控制 goroutine 的数目，完全可以把上面的两个过程拆分开：a）先通过一个 for-range 循环创建指定数目的 goroutine，b）然后通过 channel/buffered channel 给每个 goroutine 传递任务相关的信息（这里的channel是否缓冲无所谓，主要用到的是 channel 的线程安全特性）。如下图所示。</p><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gwaa7xeiyrj313q0i2wgn.jpg" alt="goroutine并发控制" title="">            </p><h5 id="goroutine并发控制方案一"><a href="#goroutine并发控制方案一" class="headerlink" title="goroutine并发控制方案一"></a>goroutine并发控制方案一</h5><p>针对上面的代码，如果想达到goroutine并发执行的控制，我们可以加个buffer channel来限制最多只有多少个goroutine在执行，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">taskCount := <span class="number">10</span></span><br><span class="line">worker := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; taskCount; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">worker &lt;- i</span><br><span class="line">fmt.Println(<span class="string">"i am worker "</span>, i)</span><br><span class="line">&lt;-worker</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过channel限制最多有三个goroutine在执行，其余的被挂起等待中，但是此方案也有个缺陷，那就是goroutine还是都被创建了，只不过这些goroutine被挂起了而已。</p><h5 id="goroutine并发控制方案二"><a href="#goroutine并发控制方案二" class="headerlink" title="goroutine并发控制方案二"></a>goroutine并发控制方案二</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">taskCount, workerCount := <span class="number">10</span>, <span class="number">3</span></span><br><span class="line">worker := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, workerCount)</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> w := <span class="keyword">range</span> worker &#123;</span><br><span class="line">fmt.Println(<span class="string">"i am worker "</span>, w)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; taskCount; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">worker &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方案二中，我们起了三个goroutine一直去消费woker以达到限制goroutine最大并发数的目的。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://jingwei.link/2019/09/13/conotrol-goroutines-count.html" target="_blank" rel="noopener">【图示】控制 Goroutine 的并发数量的方式</a>   // jing 维大佬</li><li><a href="https://eddycjy.com/posts/go/talk/2019-01-20-control-goroutine/" target="_blank" rel="noopener">来，控制一下 goroutine 的并发数量</a>        // 煎鱼老师</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;在golang语言中创建协程（Goroutine）的成本非常低，因此稍不注意就可能创建出大量的协程，一方面会造成资源的浪费，例如有一万个任务
      
    
    </summary>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/categories/golang/"/>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang goroutine浅析</title>
    <link href="https://github.com/fafucoder/2021/11/08/golang-goroutine/"/>
    <id>https://github.com/fafucoder/2021/11/08/golang-goroutine/</id>
    <published>2021-11-08T14:32:55.000Z</published>
    <updated>2023-02-04T13:33:00.724Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>什么是goroutine? Goroutine 可以看作对 thread 加的一层抽象，它更轻量级，可以单独执行。</p><h3 id="goroutine-协程-跟-线程的区别"><a href="#goroutine-协程-跟-线程的区别" class="headerlink" title="goroutine(协程) 跟 线程的区别"></a>goroutine(协程) 跟 线程的区别</h3><p>goroutine跟线程的区别可以从<code>内存消耗、创建与销毀、切换</code>三个维度说明</p><ul><li>内存创建： 创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。</li><li>创建和销毀： 线程创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。</li><li>切换： 当 threads 切换时，需要保存各种寄存器，以便将来恢复， 而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。因此goroutines 切换成本比 threads 要小得多。</li></ul><h3 id="G-P-M模型概述"><a href="#G-P-M模型概述" class="headerlink" title="G-P-M模型概述"></a>G-P-M模型概述</h3><p>在 Go 语言中，每一个 goroutine 是一个独立的执行单元，相较于每个 OS 线程固定分配 2M 内存的模式，goroutine 的栈采取了<strong>动态扩容</strong>方式， 初始时仅为<strong>2KB</strong>，随着任务执行按需增长，最大可达 1GB（64 位机器最大是 1G，32 位机器最大是 256M），且完全由 golang 自己的调度器 Go Scheduler 来调度。此外，GC 还会周期性地将不再使用的内存回收，收缩栈空间。 因此，Go 程序可以同时并发成千上万个 goroutine 是得益于它强劲的调度器和高效的内存模型。</p><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gwagya06l0j312o0swmyq.jpg" alt="G-P-M模型" title="">            </p><p>将 goroutines 调度到线程上执行，仅仅是 runtime 层面的一个概念，在操作系统之上的层面，在golang中有三个基础的结构体来实现 goroutines 的调度。g，m，p， 俗称GPM模型：</p><ul><li>G: 表示 Goroutine，每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。G 并非执行体，每个 G 需要绑定到 P 才能被调度执行。</li><li>P: Processor，表示逻辑处理器， 对 G 来说，P 相当于 CPU 核，G 只有绑定到 P(在 P 的 local runq 中)才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 &gt;= P 的数量），P 的数量由用户设置的 GOMAXPROCS 决定，但是不论 GOMAXPROCS 设置为多大，P 的数量最大为 256。</li><li>M: Machine，OS 线程抽象，代表着真正执行计算的资源，在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础，M 的数量是不定的，由 Go Runtime 调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。</li><li>每个 P 维护一个 G 的本地队列；</li><li>当一个 G 被创建出来，或者变为可执行状态时，就把他放到 P 的本地可执行队列中，如果满了则放入Global；</li><li>当一个 G 在 M 里执行结束后，P 会从队列中把该 G 取出；如果此时 P 的队列为空，即没有其他 G 可以执行， M 就随机选择另外一个 P，从其可执行的 G 队列中取走一半。</li></ul><p>除了GPM外，还有两个比较重要的组件： 全局可运行队列（GRQ）和本地可运行队列（LRQ）。 LRQ 存储本地（也就是具体的 P）的可运行 goroutine，GRQ 存储全局的可运行 goroutine，这些 goroutine 还没有分配到具体的 P。</p><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gwah8kn88jj30y40g0dhm.jpg" alt="LRQ" title="">            </p><h4 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h4><ol><li>当通过 go 关键字创建一个新的 goroutine 的时候，它会<strong>优先</strong>被放入 P 的本地队列。</li><li>为了运行 goroutine，M 需要持有（绑定）一个 P，接着 M 会启动一个 OS 线程，循环从 P 的本地队列里取出一个 goroutine 并执行。</li><li>执行调度算法：当 M 执行完了当前 P 的 Local 队列里的所有 G 后，P 也不会就这么在那划水啥都不干，它会先尝试从 Global 队列寻找 G 来执行，如果 Global 队列为空，它会随机挑选另外一个 P，从它的队列里中拿走一半的 G 到自己的队列中执行。</li></ol><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gwah30rd4dj312u0mm40a.jpg" alt="G-P-M调度模型" title="">            </p><h4 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h4><p>在四种情形下，goroutine 可能会发生调度，但也并不一定会发生，只是说 Go scheduler 有机会进行调度。</p><ol><li>使用关键字 <code>go</code>： go 创建一个新的 goroutine，Go scheduler 会考虑调度</li><li>GC: 由于进行 GC 的 goroutine 也需要在 M 上运行，因此肯定会发生调度。当然，Go scheduler 还会做很多其他的调度，例如调度不涉及堆访问的 goroutine 来运行。GC 不管栈上的内存，只会回收堆上的内存</li><li>系统调用: 当 goroutine 进行系统调用时，会阻塞 M，所以它会被调度走，同时一个新的 goroutine 会被调度上来</li><li>内存同步访问: atomic，mutex，channel 操作等会使 goroutine 阻塞，因此会被调度走。等条件满足后（例如其他 goroutine 解锁了）还会被调度上来继续运行</li></ol><h4 id="同步-异步系统调用"><a href="#同步-异步系统调用" class="headerlink" title="同步/异步系统调用"></a>同步/异步系统调用</h4><p>当 G 需要进行系统调用时，根据调用的类型，它所依附的 M 有两种情况：<code>同步</code>和<code>异步</code>。</p><ul><li><p>对于同步的情况，M 会被阻塞，进而从 P 上调度下来，P 可不养闲人，G 仍然依附于 M。之后，一个新的 M 会被调用到 P 上，接着执行 P 的 LRQ 里嗷嗷待哺的 G 们。一旦系统调用完成，G 还会加入到 P 的 LRQ 里，M 则会被“雪藏”，待到需要时再“放”出来。</p><p><img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gwah99rsymj30ya0i8goh.jpg" alt="异步调用"></p></li></ul><ul><li><p>对于异步的情况，M 不会被阻塞，G 的异步请求会被“代理人” network poller 接手，G 也会被绑定到 network poller，等到系统调用结束，G 才会重新回到 P 上。M 由于没被阻塞，它因此可以继续执行 LRQ 里的其他 G。</p><p><img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gwahbnuyfdj30xy0ho0vb.jpg" alt="异步"></p></li></ul><h3 id="goroutine状态流转"><a href="#goroutine状态流转" class="headerlink" title="goroutine状态流转"></a>goroutine状态流转</h3><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gwahdhtlrhj30yq0jmjuc.jpg" alt="状态流转" title="">            </p><h3 id="GPM结构"><a href="#GPM结构" class="headerlink" title="GPM结构"></a>GPM结构</h3><h5 id="G-结构"><a href="#G-结构" class="headerlink" title="G 结构"></a>G 结构</h5><p>g是goroutine的缩写，是goroutine的控制结构，是对goroutine的抽象。看下它内部主要的一些结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">//堆栈参数。</span></span><br><span class="line">  <span class="comment">//堆栈描述了实际的堆栈内存：[stack.lo，stack.hi）。</span></span><br><span class="line">  <span class="comment">// stackguard0是在Go堆栈增长序言中比较的堆栈指针。</span></span><br><span class="line">  <span class="comment">//通常是stack.lo + StackGuard，但是可以通过StackPreempt触发抢占。</span></span><br><span class="line">  <span class="comment">// stackguard1是在C堆栈增长序言中比较的堆栈指针。</span></span><br><span class="line">  <span class="comment">//它是g0和gsignal堆栈上的stack.lo + StackGuard。</span></span><br><span class="line">  <span class="comment">//在其他goroutine堆栈上为〜0，以触发对morestackc的调用（并崩溃）。</span></span><br><span class="line">  <span class="comment">//当前g使用的栈空间，stack结构包括 [lo, hi]两个成员</span></span><br><span class="line">  stack       stack   <span class="comment">// offset known to runtime/cgo</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用于检测是否需要进行栈扩张，go代码使用</span></span><br><span class="line">  stackguard0 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用于检测是否需要进行栈扩展，原生代码使用的</span></span><br><span class="line">  stackguard1 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当前g所绑定的m</span></span><br><span class="line">  m              *m      <span class="comment">// current m; offset known to arm liblink</span></span><br><span class="line">  <span class="comment">// 当前g的调度数据，当goroutine切换时，保存当前g的上下文，用于恢复</span></span><br><span class="line">  sched          gobuf</span><br><span class="line">  <span class="comment">// goroutine运行的函数</span></span><br><span class="line">  fnstart        *FuncVal</span><br><span class="line">  <span class="comment">// g当前的状态</span></span><br><span class="line">  atomicstatus   <span class="keyword">uint32</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当前g的id</span></span><br><span class="line">  goid           <span class="keyword">int64</span></span><br><span class="line">  <span class="comment">// 状态Gidle,Grunnable,Grunning,Gsyscall,Gwaiting,Gdead</span></span><br><span class="line">  status   <span class="keyword">int16</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下一个g的地址，通过guintptr结构体的ptr set函数可以设置和获取下一个g，通过这个字段和sched.gfreeStack sched.gfreeNoStack 可以把 free g串成一个链表</span></span><br><span class="line">  schedlink      guintptr</span><br><span class="line">  <span class="comment">// 判断g是否允许被抢占</span></span><br><span class="line">  preempt        <span class="keyword">bool</span>       <span class="comment">// preemption signal, duplicates stackguard0 = stackpreempt</span></span><br><span class="line">  <span class="comment">// g是否要求要回到这个M执行, 有的时候g中断了恢复会要求使用原来的M执行</span></span><br><span class="line">  lockedm        muintptr</span><br><span class="line">  <span class="comment">// 用于传递参数，睡眠时其它goroutine设置param，唤醒时此goroutine可以获取       param  *void</span></span><br><span class="line">  <span class="comment">// 创建这个goroutine的go表达式的pc</span></span><br><span class="line">  <span class="keyword">uintptr</span>    gopc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中包含了栈信息stackbase和stackguard，有运行的函数信息fnstart。这些就足够成为一个可执行的单元了，只要得到CPU就可以运行。goroutine切换时，上下文信息保存在结构体的sched域中。goroutine切换时，上下文信息保存在结构体的sched域中。goroutine是轻量级的<code>线程</code>或者称为<code>协程</code>，切换时并不必陷入到操作系统内核中，很轻量级。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Gobuf</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这些字段的偏移是libmach已知的（硬编码的）。</span></span><br><span class="line">    sp   uintper;</span><br><span class="line">    pc   *<span class="keyword">byte</span>;</span><br><span class="line">    g    *G;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="P-结构"><a href="#P-结构" class="headerlink" title="P 结构"></a>P 结构</h5><p>P是Processor的缩写。结构体P的加入是为了提高Go程序的并发度，实现更好的调度。M代表OS线程。P代表Go代码执行时需要的资源。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">   lock mutex</span><br><span class="line">   </span><br><span class="line">   id          <span class="keyword">int32</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// p的状态</span></span><br><span class="line">   status      <span class="keyword">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个p的地址，可参考 g.schedlink</span></span><br><span class="line">    link        puintptr　　　　<span class="comment">// 每次调用 schedule 时会加一　　　　</span></span><br><span class="line">    schedtick   <span class="keyword">uint32</span>   　　　　<span class="comment">// 每次系统调用时加一　　　　</span></span><br><span class="line">    syscalltick <span class="keyword">uint32</span>　　　　<span class="comment">// 用于 sysmon 线程记录被监控 p 的系统调用时间和运行时间　　</span></span><br><span class="line">    sysmontick  sysmontick <span class="comment">// last tick observed by sysmon10 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// p所关联的m  指向绑定的 m，如果 p 是 idle 的话，那这个指针是 nil</span></span><br><span class="line">    m           muintptr   <span class="comment">// back-link to associated m (nil if idle)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配的时候用的，p所属的m的mcache用的也是这个</span></span><br><span class="line">    mcache      *mcache</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span><br><span class="line">    <span class="comment">// 从sched中获取并缓存的id，避免每次分配goid都从sched分配</span></span><br><span class="line">    goidcache    <span class="keyword">uint64</span></span><br><span class="line">    goidcacheend <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue of runnable goroutines. Accessed without lock.</span></span><br><span class="line">    <span class="comment">// p 本地的runnbale的goroutine形成的队列</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span></span><br><span class="line">    runqtail <span class="keyword">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runnext，如果不是nil，则是已准备好运行的G</span></span><br><span class="line">    <span class="comment">//当前的G，并且应该在下一个而不是其中运行</span></span><br><span class="line">    <span class="comment">// runq，如果运行G的时间还剩时间</span></span><br><span class="line">    <span class="comment">//切片。它将继承当前时间剩余的时间</span></span><br><span class="line">    <span class="comment">//切片。如果一组goroutine锁定在</span></span><br><span class="line">    <span class="comment">//交流等待模式，该计划将其设置为</span></span><br><span class="line">    <span class="comment">//单位并消除（可能很大）调度</span></span><br><span class="line">    <span class="comment">//否则会由于添加就绪商品而引起的延迟</span></span><br><span class="line">    <span class="comment">// goroutines到运行队列的末尾。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个执行的g，如果是nil，则从队列中获取下一个执行的g</span></span><br><span class="line">    runnext guintptr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Available G's (status == Gdead)</span></span><br><span class="line">    <span class="comment">// 状态为 Gdead的g的列表，可以进行复用</span></span><br><span class="line">    gfree    *g</span><br><span class="line">    gfreecnt <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟G不同的是，P不存在<code>waiting</code>状态。MCache被移到了P中，但是在结构体M中也还保留着。在P中有一个Grunnable的goroutine队列，这是一个P的局部队列。当P执行Go代码时，它会优先从自己的这个局部队列中取，这时可以不用加锁，提高了并发度。如果发现这个队列空了，则去其它P的队列中拿一半过来，这样实现工作流窃取的调度。这种情况下是需要给调用器加锁的。</p><h5 id="M-结构"><a href="#M-结构" class="headerlink" title="M 结构"></a>M 结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// g0是用于调度和执行系统调用的特殊g</span></span><br><span class="line">   g0      *g             <span class="comment">// goroutine with scheduling stack</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// m当前运行的g</span></span><br><span class="line">   curg    *g             <span class="comment">// current running goroutine</span></span><br><span class="line">   <span class="comment">// 当前拥有的p</span></span><br><span class="line">   p        puintptr      <span class="comment">// attached p for executing go code (nil if not executing go code)</span></span><br><span class="line">   <span class="comment">// 线程的 local storage</span></span><br><span class="line">   tls      [<span class="number">6</span>]<span class="keyword">uintptr</span>    <span class="comment">// thread-local storage</span></span><br><span class="line">   <span class="comment">// 唤醒m时，m会拥有这个p</span></span><br><span class="line">   nextp         puintptr</span><br><span class="line">   id            <span class="keyword">int64</span></span><br><span class="line">   <span class="comment">// 如果 !="", 继续运行curg</span></span><br><span class="line">   preemptoff    <span class="keyword">string</span>   <span class="comment">// if != "", keep curg running on this m</span></span><br><span class="line">   <span class="comment">// 自旋状态，用于判断m是否工作已结束，并寻找g进行工作</span></span><br><span class="line">   spinning      <span class="keyword">bool</span>     <span class="comment">// m is out of work and is actively looking for work</span></span><br><span class="line">   <span class="comment">// 用于判断m是否进行休眠状态</span></span><br><span class="line">   blocked       <span class="keyword">bool</span>     <span class="comment">// m is blocked on a note</span></span><br><span class="line">   <span class="comment">// m休眠和唤醒通过这个，note里面有一个成员key，对这个key所指向的地址进行值的修改，进而达到唤醒和休眠的目的</span></span><br><span class="line">   park          note</span><br><span class="line">   <span class="comment">// 所有m组成的一个链表</span></span><br><span class="line">   alllink       *m       <span class="comment">// on allm</span></span><br><span class="line">   <span class="comment">// 下一个m，通过这个字段和sched.midle 可以串成一个m的空闲链表</span></span><br><span class="line">   schedlink     muintptr</span><br><span class="line">   <span class="comment">// mcache，m拥有p的时候，会把自己的mcache给p</span></span><br><span class="line">   mcache        *mcache</span><br><span class="line">   <span class="comment">// lockedm的对应值</span></span><br><span class="line">   lockedg       guintptr</span><br><span class="line">   <span class="comment">// 待释放的m的list，通过sched.freem 串成一个链表</span></span><br><span class="line">   freelink      *m      <span class="comment">// on sched.freem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和G类似，M中也有alllink域将所有的M放在allm链表中。lockedg是某些情况下，G锁定在这个M中运行而不会切换到其它M中去。M中还有一个MCache，是当前M的内存的缓存。M也和G一样有一个常驻寄存器变量，代表当前的M。同时存在多个M，表示同时存在多个物理线程。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://www.qcrao.com/2019/09/02/dive-into-go-scheduler/" target="_blank" rel="noopener">深度解密go语言之scheduler</a>    //绕全成大佬的解密完全看不懂</li><li><a href="https://studygolang.com/articles/29227?fr=sidebar" target="_blank" rel="noopener">GoLang GPM模型</a>  //写的不错</li><li><a href="https://zhuanlan.zhihu.com/p/95056679" target="_blank" rel="noopener">万字长文深入浅出 Golang Runtime</a>   //之前go夜读有看到分享，说的贼好</li><li><a href="https://www.cnblogs.com/33debug/p/11897627.html" target="_blank" rel="noopener">go中的协程-goroutine的底层实现</a>  // pdd 牛皮</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;什么是goroutine? Goroutine 可以看作对 thread 加的一层抽象，它更轻量级，可以单独执行。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/categories/golang/"/>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>web应用的未来是webAssembly?</title>
    <link href="https://github.com/fafucoder/2021/10/13/golang-webassembly/"/>
    <id>https://github.com/fafucoder/2021/10/13/golang-webassembly/</id>
    <published>2021-10-13T13:30:10.000Z</published>
    <updated>2021-12-17T07:42:48.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是WebAssembly"><a href="#什么是WebAssembly" class="headerlink" title="什么是WebAssembly"></a>什么是WebAssembly</h2><p>在说明什么是Webassembly之前，我们有必要了解一下asm.js。2012年，Mozilla 的工程师 Alon Zakai 在研究 LLVM 编译器时突发奇想：许多 3D 游戏都是用 C / C++ 语言写的，如果能将 C / C++ 语言编译成 JavaScript 代码，它们不就能在浏览器里运行了吗？众所周知，JavaScript 的基本语法与 C 语言高度相似。于是，他开始研究怎么才能实现这个目标，为此专门做了一个编译器项目 Emscripten。这个编译器可以将 C / C++ 代码编译成 JS 代码，但不是普通的 JS，而是一种叫做 asm.js 的 JavaScript 变体，性能差不多是原生代码的50%。</p><p>之后Google开发了Portable Native Client，也是一种能让浏览器运行C/C++代码的技术。 后来可能是因为彼此之间有共同的更高追求，Google, Microsoft, Mozilla, Apple等几家大公司一起合作开发了一个面向Web的通用二进制和文本格式的项目，那就是WebAssembly。asm.js 与 WebAssembly 功能基本一致，就是转出来的代码不一样：asm.js 是文本，WebAssembly 是二进制字节码，因此运行速度更快、体积更小。</p><p>WebAssembly(又称 wasm) 是一种新的字节码格式，主流浏览器都已经支持 WebAssembly。 和 JS 需要解释执行不同的是，WebAssembly 字节码和底层机器码很相似可快速装载运行，因此性能相对于 JS 解释执行大大提升。 也就是说 WebAssembly 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行， 浏览器厂商需要做的就是根据 WebAssembly 规范实现虚拟机。</p><p>这里引用MDN上官方对其的解释：WebAssembly是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C / C ++ / Rust等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作(总结一句话：Webassembly就像是JVM虚拟机，可以执行二进制码)。</p><blockquote><p>有人这么评价Webassembly： Webassembly是Rust押宝的唯一使用场景(Rust语言的使用场景太少了，不像golang在云原生跟中间键领域有很多应用)。</p></blockquote><h2 id="为什么需要WebAssembly"><a href="#为什么需要WebAssembly" class="headerlink" title="为什么需要WebAssembly"></a>为什么需要WebAssembly</h2><p>自从 JavaScript 诞生起到现在已经变成最流行的编程语言，这背后正是 Web 的发展所推动的。Web 应用变得更多更复杂，但这也渐渐暴露出了 JavaScript 的问题：</p><ol><li>语法太灵活导致开发大型 Web 项目困难；</li><li>性能不能满足一些场景的需要。</li></ol><p>针对以上两点缺陷，近年来出现了一些 JS 的代替语言，例如：</p><ol><li>微软的<a href="http://www.typescriptlang.org/" target="_blank" rel="noopener"> TypeScript </a>通过为 JS 加入静态类型检查来改进 JS 松散的语法，提升代码健壮性；</li><li>谷歌的<a href="https://www.dartlang.org/" target="_blank" rel="noopener"> Dart </a>则是为浏览器引入新的虚拟机去直接运行 Dart 程序以提升性能；</li><li>火狐的<a href="http://asmjs.org/" target="_blank" rel="noopener"> asm.js </a>则是取 JS 的子集，JS 引擎针对 asm.js 做性能优化。</li></ol><p>以上尝试各有优缺点，其中：</p><ol><li>TypeScript 只是解决了 JS 语法松散的问题，最后还是需要编译成 JS 去运行，对性能没有提升；</li><li>Dart 只能在 Chrome 预览版中运行，无主流浏览器支持，用 Dart 开发的人不多；</li><li>asm.js 语法太简单、有很大限制，开发效率低。</li></ol><p>三大浏览器巨头分别提出了自己的解决方案，互不兼容，这违背了 Web 的宗旨； 是技术的规范统一让 Web 走到了今天，因此形成一套新的规范去解决 JS 所面临的问题迫在眉睫。于是 WebAssembly 诞生了，WebAssembly 是一种新的字节码格式，主流浏览器都已经支持 WebAssembly。 和 JS 需要解释执行不同的是，WebAssembly 字节码和底层机器码很相似可快速装载运行，因此性能相对于 JS 解释执行大大提升。 也就是说 WebAssembly 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行， 浏览器厂商需要做的就是根据 WebAssembly 规范实现虚拟机。</p><blockquote><p>总结一句话就是：主流厂商极力主导 + webassembly速度快</p></blockquote><h2 id="Webassembly原理"><a href="#Webassembly原理" class="headerlink" title="Webassembly原理"></a>Webassembly原理</h2><p>要搞懂 WebAssembly 的原理，需要先搞懂计算机的运行原理。 电子计算机都是由电子元件组成，为了方便处理电子元件只存在开闭两种状态，对应着 0 和 1，也就是说计算机只认识 0 和 1，数据和逻辑都需要由 0 和 1 表示，也就是可以直接装载到计算机中运行的机器码。 机器码可读性极差，因此人们通过高级语言 C、C++、Rust、Go 等编写再编译成机器码。</p><p>由于不同的计算机 CPU 架构不同，机器码标准也有所差别，常见的 CPU 架构包括 x86、AMD64、ARM， 因此在由高级编程语言编译成可自行代码时需要指定目标架构。WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。</p><p>在javascript中，JavaScript引擎是执行 JavaScript 代码的程序或解释器。JavaScript引擎可以实现为标准解释器，或者以某种形式将JavaScript编译为字节码的即时编译器。不用的浏览器使用不同的引擎如下所示：</p><ul><li><p><a href="https://link.segmentfault.com/?enc=sUDGcZBE4XE+vSy5zjw84Q==.NqvwmK7YdB1NXJpJlh2DNQLg1aBzu82zEWbf/mLpt9JyjRr3+KoxkLT+FwB8JUSoRUdZr2njfFAdW/ex3PcpnA==" target="_blank" rel="noopener">V8</a> — 开源，由 Google 开发，用 C ++ 编写</p></li><li><p><a href="https://link.segmentfault.com/?enc=Lcfwj3jXwKG3LmIWG3zMdA==.96YdUZxH/6IBmMcriO6tSIZNC1VIRPZ/eQZKc278Lf6Hoz1pxLZVOwjHu0/qcOMVqZ9l7XET4ID0V4QgJc/f7w==" target="_blank" rel="noopener">Rhino</a> — 由 Mozilla 基金会管理，开源，完全用 Java 开发</p></li><li><p><a href="https://link.segmentfault.com/?enc=fEBfBX1Wd1oq35Opx9XqBg==.+OCUcVZ4OMlh0scYGO+X5yDy31T3RhLgz5LU8pR/QG3GrOaSb2UWZAqEPjXXQxNg" target="_blank" rel="noopener">SpiderMonkey</a> — 是第一个支持 Netscape Navigator 的 JavaScript 引擎，目前正供 Firefox 使用</p></li><li><p><a href="https://link.segmentfault.com/?enc=5dW2eusqpsCf0enmAMJYHg==.ecsPVoKRqxuA7xY07xwHk2pUZj9fu69Y5Xk9MFLPPcYUhCtmLH8aLW7GfggLyLZB5Fn3g7TYJR2k0t3941/3mA==" target="_blank" rel="noopener">JavaScriptCore</a> — 开源，以Nitro形式销售，由苹果为Safari开发</p></li><li><p><a href="https://link.segmentfault.com/?enc=wE8dCPOCitI59es0P62axw==.NQQ7Mbn0KzdeG2aWMep/ZoMepjYQU0i2Y70FT0ArpGB6zy+1ygTmPYQDKCYBwp3bzBw4MzXWC2RvNNsv1WCpUg==" target="_blank" rel="noopener">KJS</a> — KDE 的引擎，最初由 Harri Porten 为 KDE 项目中的 Konqueror 网页浏览器开发</p></li><li><p><a href="https://link.segmentfault.com/?enc=4p1lBDVXg9F3LoYDCAYqZw==.69EhewNej7/0qL6i/vfOmKrHRr8J75bQnL6m3/Pq/NJ9B/5ltxTPYbJTUIhqMwAMHFWYhsMI6zbTzo/cs4QMyA==" target="_blank" rel="noopener">Chakra</a> (JScript9) — Internet Explorer</p></li><li><p><a href="https://link.segmentfault.com/?enc=HbF4R5UwNZvgHmR/1wtgDQ==.eZWlURXx88Zj4cbJlV52kYcs6ilppQjxqB9f0e/bKPr6736fvUxWXbL77DDy7W8ONHasBxCyxiS/G07KFi3mIQ==" target="_blank" rel="noopener">Chakra</a> (JavaScript) — Microsoft Edge</p></li><li><p><a href="https://link.segmentfault.com/?enc=JJkYtp97F7aGkuRpJu4j+A==.m2XjtFgQZ+p7pfw2mm6hzwz8hHSy2krktwpxq8U1xVjUx1swsJd9bpTYlTiR4YQF5iEyx+frqx1Ir7CGq4Yi8A==" target="_blank" rel="noopener">Nashorn</a>, 作为 OpenJDK 的一部分，由 Oracle Java 语言和工具组编写</p></li><li><p><a href="https://link.segmentfault.com/?enc=s1goWbasfcZ7FRTX379/UA==.utRib33Njx3A6/klirW/KCvy0haJmdcHrB0fRetgT6Kg+zz1lM2n0QTZNDYWTvPE" target="_blank" rel="noopener">JerryScript</a> — 物联网的轻量级引擎</p></li></ul><p>因此我们看下javascript在V8引擎下的工作机制: javacript运行中，引擎首先解析javascript生成抽象语法树(AST), 然后生成机器码。</p><p class="img-lightbox">                <img src="https://i7drsi3tvf.feishu.cn/space/api/box/stream/download/asynccode/?code=M2NkMjI2MTBlMDY5ZjIzNzQxMzk2NWMxYzI3ZjQwNDFfSUhEV1hsbGlFRFl5bU5xTUs1NEJKV3pjU2ZBZTFRWWNfVG9rZW46Ym94Y25iNERHS1doN25BNkxpdGE2dGdVaDdSXzE2MzQxMzE5MDM6MTYzNDEzNTUwM19WNA" alt="img" title="">            </p><p>接着通过V8 的优化编译器 (TurboFan)的优化，把优化后的机器码推向后端(所谓的后端就是即时编译器JIT)</p><p class="img-lightbox">                <img src="https://i7drsi3tvf.feishu.cn/space/api/box/stream/download/asynccode/?code=ODlmMmQ3ZDBmMDdmYTgyYmE5MGM0YWI2MjdmMzdjNDBfbXNsRXN5TThZMU9mdGJPYU42eVFBd2xrQXY0RjRrTnNfVG9rZW46Ym94Y256MFZjSGFHZHUwc3VoU2M5WG4xYkxpXzE2MzQxMzE5MDM6MTYzNDEzNTUwM19WNA" alt="img" title="">            </p><p>但是webassembly并不需要以上的全部步骤－如下所示是它被插入到执行过程示意图:</p><p class="img-lightbox">                <img src="https://i7drsi3tvf.feishu.cn/space/api/box/stream/download/asynccode/?code=MzlhZTAzZjExYzVhYjFmZTY2MGJhZDdiNTFmNWM0MWFfUTVrRVZuMWxhMVlpMTcwN3lDVmJaYVV4WHZaVm5oNVpfVG9rZW46Ym94Y25aUEFUWlAxUm44SjJjbzZjQ3NUREdnXzE2MzQxMzE5MDM6MTYzNDEzNTUwM19WNA" alt="img" title="">            </p><p>可以看到webassembly并不需要编译阶段，而是直接把编译后的字节码发送给后端，因此速度更快。</p><p>目前能编译成 WebAssembly 字节码的高级语言有：</p><ul><li><p><a href="https://github.com/AssemblyScript/assemblyscript">AssemblyScript</a>:语法和 TypeScript 一致，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；</p></li><li><p>C\C++:官方推荐的方式，详细使用见<a href="http://webassembly.org.cn/getting-started/developers-guide/" target="_blank" rel="noopener">文档</a>;</p></li><li><p><a href="https://www.rust-lang.org/" target="_blank" rel="noopener">Rust</a>:语法复杂、学习成本高，详细使用见<a href="https://github.com/rust-lang-nursery/rust-wasm">文档</a>;</p></li><li><p><a href="http://kotlinlang.org/" target="_blank" rel="noopener">Kotlin</a>:语法和 Java、JS 相似，语言学习成本低，详细使用见<a href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noopener">文档</a>;</p></li><li><p><a href="https://golang.org/" target="_blank" rel="noopener">Golang</a>:语法简单学习成本低。详细使用见<a href="https://blog.gopheracademy.com/advent-2017/go-wasm/" target="_blank" rel="noopener">文档</a>。</p></li><li><p>其他语言: 详细见<a href="https://github.com/appcypher/awesome-wasm-langs">文档</a>。</p></li></ul><h2 id="Webassembly使用场景："><a href="#Webassembly使用场景：" class="headerlink" title="Webassembly使用场景："></a>Webassembly使用场景：</h2><p>总体而言，WASM不会替代JavaScript，但是却可以辅助解决很多JavaScript无法解决的问题。下面是Webassembly的一些场景：</p><h5 id="浏览器场景："><a href="#浏览器场景：" class="headerlink" title="浏览器场景："></a>浏览器场景：</h5><ul><li><p>更好的让一些语言和工具可以编译到 Web 平台运行。</p></li><li><p>图片/视频编辑。</p></li><li><p>游戏：</p><ul><li>需要快速打开的小游戏</li></ul></li><li><p>AAA 级，资源量很大的游戏。</p></li><li><p>游戏门户（代理/原创游戏平台）</p></li><li><p>P2P 应用（游戏，实时合作编辑）</p></li><li><p>音乐播放器（流媒体，缓存）</p></li><li><p>图像识别</p></li><li><p>视频直播</p></li><li><p>VR 和虚拟现实</p></li><li><p>CAD 软件</p></li><li><p>科学可视化和仿真</p></li><li><p>互动教育软件和新闻文章。</p></li><li><p>模拟/仿真平台(ARC, DOSBox, QEMU, MAME, …)。</p></li><li><p>语言编译器/虚拟机。</p></li></ul><h5 id="非浏览器场景："><a href="#非浏览器场景：" class="headerlink" title="非浏览器场景："></a>非浏览器场景：</h5><ul><li><p>游戏分发服务（便携、安全）。</p></li><li><p>服务端执行不可信任的代码。</p></li><li><p>服务端应用。</p></li><li><p>移动混合原生应用。</p></li><li><p>多节点对称计算</p></li></ul><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>基于golang实现webassembly的demo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是WebAssembly&quot;&gt;&lt;a href=&quot;#什么是WebAssembly&quot; class=&quot;headerlink&quot; title=&quot;什么是WebAssembly&quot;&gt;&lt;/a&gt;什么是WebAssembly&lt;/h2&gt;&lt;p&gt;在说明什么是Webassembly之前，我们
      
    
    </summary>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/categories/golang/"/>
    
    
      <category term="golang" scheme="https://github.com/fafucoder/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>nodejs中package.json的常见字段</title>
    <link href="https://github.com/fafucoder/2021/10/12/node-package-json/"/>
    <id>https://github.com/fafucoder/2021/10/12/node-package-json/</id>
    <published>2021-10-12T15:42:34.000Z</published>
    <updated>2023-01-14T07:39:00.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://www.cnblogs.com/luowen075/p/10361211.html" target="_blank" rel="noopener">https://www.cnblogs.com/luowen075/p/10361211.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/212832506" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/212832506</a></li><li><a href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json#browser" target="_blank" rel="noopener">https://docs.npmjs.com/cli/v7/configuring-npm/package-json#browser</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考文档&quot;&gt;&lt;a href=&quot;#参考文档&quot; class=&quot;headerlink&quot; title=&quot;参考文档&quot;&gt;&lt;/a&gt;参考文档&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/luowen075/p/10361211.ht
      
    
    </summary>
    
    
      <category term="nodejs" scheme="https://github.com/fafucoder/categories/nodejs/"/>
    
    
      <category term="nodejs" scheme="https://github.com/fafucoder/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>网络加速方案dpdk</title>
    <link href="https://github.com/fafucoder/2021/10/12/linux-dpdk/"/>
    <id>https://github.com/fafucoder/2021/10/12/linux-dpdk/</id>
    <published>2021-10-12T13:38:34.000Z</published>
    <updated>2021-12-17T07:42:48.341Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://mp.weixin.qq.com/s/GaCbRbZJnCR9ZeRUsyZtAw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GaCbRbZJnCR9ZeRUsyZtAw</a></li><li><a href="https://blog.csdn.net/cloudvtech/article/details/80359834" target="_blank" rel="noopener">https://blog.csdn.net/cloudvtech/article/details/80359834</a></li><li><a href="https://www.zhihu.com/question/56820346" target="_blank" rel="noopener">https://www.zhihu.com/question/56820346</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考文档&quot;&gt;&lt;a href=&quot;#参考文档&quot; class=&quot;headerlink&quot; title=&quot;参考文档&quot;&gt;&lt;/a&gt;参考文档&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/GaCbRbZJnCR9ZeRUsyZt
      
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/categories/linux/"/>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>nodejs中require跟import的区别</title>
    <link href="https://github.com/fafucoder/2021/10/12/node-require/"/>
    <id>https://github.com/fafucoder/2021/10/12/node-require/</id>
    <published>2021-10-12T13:25:22.000Z</published>
    <updated>2021-12-17T07:42:48.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p> require/exports 出生在野生规范当中，什么叫做野生规范？即这些规范是 JavaScript 社区中的开发者自己草拟的规则，得到了大家的承认或者广泛的应用。比如 CommonJS、AMD、CMD 等等。import/export 则是名门正派。TC39 制定的新的 ECMAScript 版本，即 ES6（ES2015）中包含进来。</p></blockquote><p>关于 <code>import</code> 和 <code>require</code> 的不同，其实可以理解成 CommonJs 和 ES Module 的区别。这两者都是前端模块化的规范。</p><h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><p>Nodejs 是 CommonJS 规范的主要实践者，在 CommonJs 里每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.MyClass = Myclass</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyClass = <span class="built_in">require</span>(<span class="string">'./myclass.js'</span>)</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> MyClass(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure><h4 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h4><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。所以ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code> 命令输入。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'./myclass'</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> MyClass(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th>命令</th><th align="left">规范</th><th>调用</th><th>本质</th><th align="left">特点</th></tr></thead><tbody><tr><td>require</td><td align="left">CommonJS规范</td><td>运行时调用</td><td>赋值过程</td><td align="left">非语言层面的标准。 社区方案，提供了服务器/浏览器的模块加载方案。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。</td></tr><tr><td>import</td><td align="left">es6+的语法标准</td><td>编译时调用</td><td>解构过程</td><td align="left">语言规格层面支持模块功能。支持编译时静态分析，便于JS引入宏和类型检验。动态绑定</td></tr></tbody></table><h3 id="关于调用"><a href="#关于调用" class="headerlink" title="关于调用"></a>关于调用</h3><ol><li>require的引用可以在代码的任何地方。</li><li>import语法规范上是放在文件开头。</li></ol><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://juejin.cn/post/6844903765489745927" target="_blank" rel="noopener">https://juejin.cn/post/6844903765489745927</a> // 值得一看</li><li><a href="https://www.zhihu.com/question/56820346" target="_blank" rel="noopener">https://www.zhihu.com/question/56820346</a>     // 值得一看</li><li><a href="https://segmentfault.com/a/1190000023082896" target="_blank" rel="noopener">https://segmentfault.com/a/1190000023082896</a>  // 值得一看</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; require/exports 出生在野生规范当中，什么叫做野生规范？即这些规范是 JavaScript 社区中
      
    
    </summary>
    
    
      <category term="nodejs" scheme="https://github.com/fafucoder/categories/nodejs/"/>
    
    
      <category term="nodejs" scheme="https://github.com/fafucoder/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>linux top命令</title>
    <link href="https://github.com/fafucoder/2021/09/18/linux-top/"/>
    <id>https://github.com/fafucoder/2021/09/18/linux-top/</id>
    <published>2021-09-18T07:56:48.000Z</published>
    <updated>2023-02-04T13:33:00.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="top命令参数信息"><a href="#top命令参数信息" class="headerlink" title="top命令参数信息"></a>top命令参数信息</h3><p>在命令top中可以方便的查看系统的cpu和内存信息(如下图所示), 然后你可能不清楚每一个字段代表的含义，现在就一块揭秘top命令中每个字段的含义</p><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gut64f02osj61h40octfj02.jpg" alt="top command" title="">            </p><p><code>us</code>：user time，表示 CPU 执行用户进程的时间，包括 nice 时间。通常都是希望用户空间CPU越高越好。</p><p><code>sy</code>：system time，表示 CPU 在内核运行的时间，包括 IRQ 和 softirq。系统 CPU 占用越高，表明系统某部分存在瓶颈。通常这个值越低越好。</p><p><code>ni</code>：nice time，具有优先级的用户进程执行时占用的 CPU 利用率百分比。</p><p><code>id</code>：idle time，表示系统处于空闲期，等待进程运行。</p><p><code>wa</code>：waiting time，表示 CPU 在等待 IO 操作完成所花费的时间。系统不应该花费大量的时间来等待 IO 操作，否则就说明 IO 存在瓶颈。</p><p><code>hi</code>：hard IRQ time，表示系统处理硬中断所花费的时间。</p><p><code>si</code>：soft IRQ time，表示系统处理软中断所花费的时间。</p><p><code>st</code>：steal time，被强制等待（involuntary wait）虚拟 CPU 的时间，此时 Hypervisor 在为另一个虚拟处理器服务</p><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gut6kntlhpj61hc0u0gqf02.jpg" alt="top cpu command" title="">            </p><h4 id="cpu-平均负载Load-Average"><a href="#cpu-平均负载Load-Average" class="headerlink" title="cpu 平均负载Load Average"></a>cpu 平均负载Load Average</h4><p>​    在上面的top命令中跟cpu相关的信息还有一个叫load average, load average这一列中的三个数值分别表示过去一分钟，五分钟，十五分钟这个节点上的load average。那么到底啥是load average呢?</p><p>​    这里的load average表示对CPU资源需求的度量(说的很好，但是等于放屁~)，举个例子你可能就懂了，对于一个单个 CPU 的系统，如果在 1 分钟的时间里，处理器上始终有一个进程在运行，同时操作系统的进程可运行队列中始终都有 9 个进程在等待获取 CPU 资源。那么对于这 1 分钟的时间来说，系统的”load average”就是 1+9=10(这个定义对绝大部分的Unix 系统都适用)。</p><p>总结一句话就是: load average 等于单位时间内正在运行的进程+可运行队列的进程(注意，<strong>这里说的是unix系统</strong>)，因此：</p><ul><li>第一，不论计算机 CPU 是空闲还是满负载，Load Average 都是 Linux 进程调度器中<strong>可运行队列（Running Queue）里的一段时间的平均进程数目。</strong></li><li>第二，计算机上的 CPU 还有空闲的情况下，CPU Usage 可以直接反映到”load average”上，什么是 CPU 还有空闲呢？具体来说就是可运行队列中的进程数目小于 CPU个数，这种情况下，单位时间进程 CPU Usage 相加的平均值应该就是”load average”的值。</li><li>第三，计算机上的 CPU 满负载的情况下，计算机上的 CPU 已经是满负载了，同时还有更多的进程在排队需要 CPU 资源。这时”load average”就不能和 CPU Usage 等同了。比如对于单个 CPU 的系统，CPU Usage 最大只是有 100%，也就 1 个 CPU；而”loadaverage”的值可以远远大于 1，因为”load average”看的是操作系统中可运行队列中进程的个数。</li></ul><p><strong>对于linux系统来说： load average = 可运行队列的进程 + 处于TASK_UNINTERRUPTIBLE状态的进程(D 状态进程)</strong></p><blockquote><p>TASK_UNINTERRUPTIBLE 是 Linux 进程状态的一种，是进程为等待某个系统资源而进入了睡眠的状态，并且这种睡眠的状态是不能被信号打断的。俗称D状态进程</p><p>因此，如果发现系统的load average很高，而CPU还是处于空闲状态，说明有很多进程处于阻塞状态，这时候得检查下代码写的是否有问题啦~(通过 ps 命令可以查阅D状态进程的信息)</p></blockquote><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gut7nhnp8kj61hc0u0ac602.jpg" alt="load average" title="">            </p><h3 id="top命令原理"><a href="#top命令原理" class="headerlink" title="top命令原理"></a>top命令原理</h3><p>分析了top命令中cpu字段的含义，你肯定还有疑问top命令中的数值是怎么计算出来的，</p><h3 id="容器中如何查看cpu信息"><a href="#容器中如何查看cpu信息" class="headerlink" title="容器中如何查看cpu信息"></a>容器中如何查看cpu信息</h3><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://github.com/silenceshell/topic">https://github.com/silenceshell/topic</a>  // 容器中正确展示top信息</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;top命令参数信息&quot;&gt;&lt;a href=&quot;#top命令参数信息&quot; class=&quot;headerlink&quot; title=&quot;top命令参数信息&quot;&gt;&lt;/a&gt;top命令参数信息&lt;/h3&gt;&lt;p&gt;在命令top中可以方便的查看系统的cpu和内存信息(如下图所示), 然后你可能不清楚
      
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/categories/linux/"/>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes pause容器解析</title>
    <link href="https://github.com/fafucoder/2021/09/13/kubernetes-pause/"/>
    <id>https://github.com/fafucoder/2021/09/13/kubernetes-pause/</id>
    <published>2021-09-13T06:25:36.000Z</published>
    <updated>2021-12-17T07:42:48.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/66252461" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66252461</a>  //知乎专栏</li><li><a href="https://cloud.tencent.com/developer/article/1375877" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1375877</a> //腾讯云</li><li><a href="https://github.com/kubernetes/kubernetes/tree/master/build/pause">https://github.com/kubernetes/kubernetes/tree/master/build/pause</a>  // pause 源码解析</li><li><a href="https://o-my-chenjian.com/2017/10/17/The-Pause-Container-Of-Kubernetes/" target="_blank" rel="noopener">https://o-my-chenjian.com/2017/10/17/The-Pause-Container-Of-Kubernetes/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考文档&quot;&gt;&lt;a href=&quot;#参考文档&quot; class=&quot;headerlink&quot; title=&quot;参考文档&quot;&gt;&lt;/a&gt;参考文档&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66252461&quot; target=&quot;
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://github.com/fafucoder/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://github.com/fafucoder/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>linux中的page cache</title>
    <link href="https://github.com/fafucoder/2021/08/24/linux-pagecache/"/>
    <id>https://github.com/fafucoder/2021/08/24/linux-pagecache/</id>
    <published>2021-08-24T12:31:11.000Z</published>
    <updated>2023-02-04T13:33:00.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p class="img-lightbox">                <img src="https://fafucoder-1252756369.cos.ap-nanjing.myqcloud.com/008i3skNly1gts5qs2lggj30u00wnq4v.jpg" alt="vfs" title="">            </p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://spongecaptain.cool/SimpleClearFileIO/1.%20page%20cache.html" target="_blank" rel="noopener">https://spongecaptain.cool/SimpleClearFileIO/1.%20page%20cache.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;图片&quot;&gt;&lt;a href=&quot;#图片&quot; class=&quot;headerlink&quot; title=&quot;图片&quot;&gt;&lt;/a&gt;图片&lt;/h3&gt;&lt;p class=&quot;img-lightbox&quot;&gt;
                &lt;img src=&quot;https://fafucoder-1252
      
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/categories/linux/"/>
    
    
      <category term="linux" scheme="https://github.com/fafucoder/tags/linux/"/>
    
  </entry>
  
</feed>
